[{"content":"","date":1508426775,"description":"Text about this post","lastmod":"2019-10-26T15:26:15Z","objectID":"3976528693a0108357f4928017600865","permalink":"https://butr.github.io/documentation/","publishdate":"2018-11-23T15:26:15Z","title":"Home title"},{"content":"","date":1639584240,"description":"","lastmod":"2021-12-15T19:04:00+03:00","objectID":"65a97066c0c3d6bcb7bfdd734849a02f","permalink":"https://butr.github.io/documentation/advanced/","publishdate":"2021-12-15T19:04:00+03:00","title":"Advanced"},{"content":"Introduction ButterLib v2.2.4 added a new entry in its Crash Report section called Enhanced Stacktrace.\nIt provides more info about the stacktrace of the exception -every frame (method call) provides more info:\nIf the method is changed by Harmony, it shows the original method and any prefix, postfix, transpiler or finalizer that is added, included with the Module that introduces the patch; An IL Offset is added; IL Offsets You should be able to know now the line that caused the exception, even if no debug symbols were present at the time of the crash.\nThis will be the most helpful when debugging vanilla game code.\nHere\u0026amp;rsquo;s how to use it:\nDownload dnSpy or any other software that can show the IL code of a method; Convert the IL Offset to hexadecimal; Open the IL Code of the method; The IL Offset will link to the exact line the code threw an exception; Example As an example, here\u0026amp;rsquo;s a crash report. The IL Offset of the method CalculateSettlementValueForFaction is 73 (0x49 hex).\nThe IL code shows that at 0049 is the line\nitemObject.ItemHolsters = (string[])craftedData.Template.ItemHolsters.Clone(); On which the NullReferenceException occured.\n","date":1666385100,"description":"","lastmod":"2022-10-21T23:45:00+03:00","objectID":"8bc71d0d893ea6ba8962fb6589e6bcb2","permalink":"https://butr.github.io/documentation/advanced/advanced-analytics-crash-reports/","publishdate":"2022-10-21T23:45:00+03:00","title":"Advanced Stacktrace Analytics of Crash Reports"},{"content":"Introduction Sometimes you need to use a game function, but with some parts disabled. For example, Clan.OnCompanionAdded not only adds a hero to the clan companion list, but also adds him to the hero list.\npublic void OnCompanionAdded(Hero companion) { _companionsCache.Add(companion); OnHeroAdded(companion); // Function that adds the hero to the hero list } But what if we don\u0026amp;rsquo;t want this? One way you could just copy the function and get the maintenance burden of it.\nAnother way would be to use a Harmony reverse patch. You can get a copy of the function and manually manipulate the IL code to disable the OnHeroAdded call.\nWe suggest a higher level approach, based on using scopes and IDisposable.\nScoped Disabling Technique using allows us to create a scope. While this scope is active, we use a harmony patch that disables the execution of the unwanted function.\nusing (new AddCompanionActionHandler()) { // Within this scope any call to `OnHeroAdded` will be skipped. oldLeader.Clan.OnCompanionAdded(oldLeader); } The Harmony patch\npublic class AddCompanionActionHandler : IDisposable { public AddCompanionActionHandler() =\u0026amp;gt; AddCompanionActionPatch.SkipChange = true; public void Dispose() =\u0026amp;gt; AddCompanionActionPatch.SkipChange = false; } internal class AddCompanionActionPatch { internal static bool SkipChange = false; public static bool Enable(Harmony harmony) { return true \u0026amp;amp; harmony.TryPatch( original: AccessTools2.Method(typeof(Clan), \u0026amp;#34;OnHeroAdded\u0026amp;#34;), prefix: AccessTools2.Method(typeof(AddCompanionActionPatch), nameof(Prefix))); } private static bool Prefix() =\u0026amp;gt; !SkipChange; } ","date":1669329e3,"description":"","lastmod":"2022-11-25T01:30:00+03:00","objectID":"a38e875b00c573d97d1e931ce0277496","permalink":"https://butr.github.io/documentation/advanced/disabling-parts-of-external-functions/","publishdate":"2022-11-25T01:30:00+03:00","title":"Disabling Parts of External Functions"},{"content":"Introduction We created some easy to use reusable workflows that you can use to automatically publish your mods on NexusMods, Steam Workshop, NuGet/GPR and GitHub Releases.\nThe workflow is a multijob.\nHere\u0026amp;rsquo;s a full example.\nFirst, you need to build your module on GitHub Actions and publish the binaries as an artifact.\nHere\u0026amp;rsquo;s an abstract example that uses Bannerlord.BuildResources for automatically building the mod with the proper structure.\nbuild-module: name: Build Module runs-on: ubuntu-latest steps: - name: Checkout Repository uses: actions/checkout@v2 - name: Setup .NET 6 uses: actions/setup-dotnet@master with: dotnet-version: 6.0.x - name: Build Bannerlord.Module run: \u0026amp;gt;- mkdir bannerlord; dotnet build src/Bannerlord.Module/Bannerlord.Module.csproj --configuration Release -p:GameFolder=\u0026amp;#34;$PWD/bannerlord\u0026amp;#34;; shell: pwsh - name: Upload Bannerlord folder uses: actions/upload-artifact@v3 with: name: bannerlord path: ./bannerlord/ NexusMods NexusMods will require you to set the proper ModId (nexusmods_mod_id), this is the number at the end of your mod url.\nAlso, it will require to set 2 secrets, NEXUSMODS_APIKEY and NEXUSMODS_COOKIES.\nYou can get the ApiKey from here. The Cookies will require you to log in to NexusMods via Firefox.\nF12 and go to Network tab. Find any XHR method to nexusmods.com and copy the Cookies header. This is our NEXUSMODS_COOKIES secret.\npublish-on-nexusmods: needs: [\u0026amp;#34;build-module\u0026amp;#34;] uses: BUTR/workflows/.github/workflows/release-nexusmods.yml@master with: nexusmods_game_id: mountandblade2bannerlord nexusmods_mod_id: 0 mod_filename: Bannerlord.Module mod_version: INJECT YOUR VERSION SOMEHOW mod_description: INJECT YOUR CHANGELOG SOMEHOW artifact_name: bannerlord secrets: NEXUSMODS_APIKEY: ${{ secrets.NEXUSMODS_APIKEY }} NEXUSMODS_COOKIES: ${{ secrets.NEXUSMODS_COOKIES }} Steam If Steam Guard is used, you need the STEAM_AUTH_CODE secret. Follow this url as a guide:\nYou need to either switch to Steam Desktop …","date":1669739400,"description":"","lastmod":"2022-11-29T19:30:00+03:00","objectID":"bbbddb8b17ba2493786a45cb5373f1ae","permalink":"https://butr.github.io/documentation/advanced/publishing-on-github/","publishdate":"2022-11-29T19:30:00+03:00","title":"Publishing Mods on GitHub Actions (NexusMods, Steam Workshop, NuGet)"},{"content":"Introduction Using any of the MemberInfo types is slow. Especially when they are not cached.\nA better way for accessing type members is to create delegates, with them the access speed is on pair with direct access.\nHarmony created a helper class AccessTools for those cases and BUTR created an extended version of it.\nIn this article we\u0026amp;rsquo;ll show how you can speed up your code.\nCaching Always cache the reflection if it\u0026amp;rsquo;s gonna be called multiple times.\nHarmony We strongly recommend to check first the Harmony Documentation as the code base is based on it.\nYou will also need Harmony.Extensions for the AccessTools2 class.\nAccessing fields // Usually it\u0026amp;#39;s done like this: private static readonly FieldInfo? Info = AccessTools2.Field(typeof(LauncherModuleVM), \u0026amp;#34;Info\u0026amp;#34;); // And then invoked like this: LauncherModuleVM obj = ...; // the LauncherModuleVM instance if (Info is not null) { string str = Info.GetValue(obj); Info.SetValue(obj, \u0026amp;#34;newstr\u0026amp;#34;); } // Instead use AccessTools.FieldRef private static readonly AccessTools.FieldRef\u0026amp;lt;string, LauncherModuleVMType\u0026amp;gt;? Info = AccessTools2.FieldRefAccess\u0026amp;lt;string, LauncherModuleVMType\u0026amp;gt;(\u0026amp;#34;Info\u0026amp;#34;); LauncherModuleVM obj = ...; // the LauncherModuleVM instance if (Info is not null) { string str = Info(obj); Info(obj) = \u0026amp;#34;newstr\u0026amp;#34;; } Calling methods // Usually it\u0026amp;#39;s done like this: private static readonly MethodInfo? Method = AccessTools2.Method(typeof(LauncherModuleVM), \u0026amp;#34;Method\u0026amp;#34;); // And then invoked like this: LauncherModuleVM obj = ...; // the LauncherModuleVM instance if (Method is not null) { bool b = Info.Invoke(obj, new object[] {}); } // Instead use AccessTools.FieldRef private delegate bool MethodDelegate(LauncherModuleVM instance); private static readonly MethodDelegate Method = AccessTools2.GetDelegate\u0026amp;lt;MethodDelegate\u0026amp;gt;(typeof(LauncherModuleVM), \u0026amp;#34;Method\u0026amp;#34;); LauncherModuleVM obj = ...; // the LauncherModuleVM instance if (Method is not null) { bool b = …","date":1639650721,"description":"","lastmod":"2021-12-16T13:32:01+03:00","objectID":"a8c30552768c06117b59c79bb1c7ba54","permalink":"https://butr.github.io/documentation/advanced/switching-from-membertinfo-to-accesstools2/","publishdate":"2021-12-16T13:32:01+03:00","title":"Switching from MemberInfo to AccessTools2"},{"content":"Introduction Our BUTR mods have a famous history of backwards compatibility.\nWe use several techniques to achieve this without causing huge performance drops by using Harmony\u0026amp;rsquo;s built in reflection tools and caching.\nOne of the techniques we use is type wrapping.\nIt\u0026amp;rsquo;s used for several cases:\nWhen types are moved between assemblies. Generally, to fix this you need to recompile your mod with the new locations, but it won\u0026amp;rsquo;t be backwards compatible this way. Instead, we stop working with the type directly and wrap it as an object, exposing an abstraction to work with. Incompatible signature changes. The method signature was replaced without keeping the old signature. Depending on the game version, you\u0026amp;rsquo;ll need to call different methods. Type Move Read-life example of type move.\nIn our BUTRLoader, we target e1.5.0 as the minimal supported version. Since the type was moved in e1.5.x, we either need to have 2 compiled assemblies and load one depending on the game version (see Implementation Loading), or create a type wrapper, what we did.\n// The game at some point moved type ModuleInfo // TaleWorlds.Library.ModuleInfo // to // TaleWorlds.ModuleManager.ModuleInfo // The type can\u0026amp;#39;t be directly referenced and used because it\u0026amp;#39;s location // is not consistent anymore/ // So we instead create a wrapper class that access the type indirectly internal sealed class ModuleInfoWrapper { private delegate string GetIdDelegate(object instance); private delegate string GetAliasDelegate(object instance); private delegate bool GetIsSelectedDelegate(object instance); private static readonly Type? OldModuleInfoType = AccessTools2.TypeByName(\u0026amp;#34;TaleWorlds.Library.ModuleInfo\u0026amp;#34;); private static readonly Type? NewModuleInfoType = AccessTools2.TypeByName(\u0026amp;#34;TaleWorlds.ModuleManager.ModuleInfo\u0026amp;#34;); public static readonly Type? ModuleInfoType = OldModuleInfoType ?? NewModuleInfoType; private static readonly GetIdDelegate? GetId = …","date":1639580221,"description":"","lastmod":"2021-12-15T17:57:01+03:00","objectID":"ff51d580fb08e43ef450d500921197aa","permalink":"https://butr.github.io/documentation/advanced/type-wrapping/","publishdate":"2021-12-15T17:57:01+03:00","title":"Type Wrapping"},{"content":"Introduction Both the Vanilla Game and ButterLib provide dump (.dmp) files that modders can use to open in Visual Studio and see both the stacktrace, threads and stack variables to get more info about a crash.\nHow to Get a Dump The game creates a dump file at C:\\ProgramData\\Mount and Blade II Bannerlord\\crashes after agreeing with the game prompt to send to the developers the crash report.\nThe dump is fairly big, because it has a lot of flags by default:\nMiniDumpWithDataSegs | MiniDumpWithHandleData | MiniDumpScanMemory | MiniDumpWithUnloadedModules | MiniDumpWithIndirectlyReferencedMemory | MiniDumpWithProcessThreadData | MiniDumpWithFullMemoryInfo | MiniDumpWithThreadInfo | MiniDumpWithFullAuxiliaryState | MiniDumpIgnoreInaccessibleMemory | MiniDumpWithTokenInformation | MiniDumpWithModuleHeaders ButterLib generates a dump file inside the crash report only when the report is saved locally as a file.\nWhen the html file is opened, a button appears Get Minidump that will save the dump as a separate file. Out flags are:\nMiniDumpFilterModulePaths | MiniDumpWithIndirectlyReferencedMemory | MiniDumpScanMemory Analyzing the Dump After opening the dump in Visual Studio, you won\u0026amp;rsquo;t get any useful data first.\nThis is because we need to start a debug session (Debug with Managed Only) and show VS where both the .dll and .pdb (symbols) files are.\nThe game doesn\u0026amp;rsquo;t provide the .pdb files, but they can be created by ILSpy and JetBrains dotPeek.\nOpen the .dll files there and when right clicking on the file a prompt about creating a .pdb file should appear.\nAfter that, link VS to them and you should have a standard exception window with the source code!\n","date":1666534320,"description":"","lastmod":"2022-10-23T17:12:00+03:00","objectID":"97eaedff6fd2b5e0047150d33a015210","permalink":"https://butr.github.io/documentation/advanced/using-butterlib-crash-dump/","publishdate":"2022-10-23T17:12:00+03:00","title":"Using ButterLib's Crash Dump"},{"content":"The first step to opening a non-zip mod is installing software on your computer that can open it. On Windows, you can use a program such as 7-Zip, which is free and open source, meaning you can check the code yourself and modify it before installing it.\nHow to Install 7Zip After the 7Zip download and launching, you will be amazed by how easy and simple to navigate through its user interface. In downloading 7Zip for Mac or Linux, just follow the steps discussed.\nGo to 7Zip’s home page and choose the version you wish to download. As of this writing, these are the versions available.\nChoose the version you want and click on the Download button. A new window appears which asks you what directory you like to install the program. Choose the destination folder you wish to save the program and click Install.\nOnce the 7Zip is installed, hit the Finish button. That’s everything you have to do. Now, let’s proceed on how to use 7Zip and other vital product details and information.\nNavigating through 7Zip’s UI Inside the window, you’ll see the main toolbar containing the most useful features and other menus that let you dig deeper and be accustomed to its UI. Some of the features are briefly discussed below:\nExtract – a button that allows you to accept or browse for the default destination path for your file easily. View – this menu contains the Folder History as well as the Favorites menu which allows you to save to as much as ten folders.\n7Zip can integrate with the Windows Explorer menu which displays archive files as folders. At the same time, it provides a toolbar with a drag-and-drop feature. It is possible as well to switch between a single or even dual-pane view. 7Zip password protect can help you protect the program. Extraction When extracting files, there are 5 straightforward steps you need to do. Just check the instructions below.\nSelect the files that you want to extract. Choose files you wish to extract and press right-click. This will open a new menu. Hover over …","date":1629543600,"description":"","lastmod":"2021-08-21T14:00:00+03:00","objectID":"c83bbc0e4cbc0e45701963843e4c6722","permalink":"https://butr.github.io/documentation/info/unpacking-7z-files/","publishdate":"2021-08-21T14:00:00+03:00","title":"Unpacking .7z files"},{"content":"Introduction TaleWorlds have their own Crash Reporing mechanism that we modders can use! It provides less info for us, but it\u0026amp;rsquo;s better than nothing.\nIf ButterLib or Better Exception Window doesn\u0026amp;rsquo;t generate their Crash Reports, we recommend sending the TW dump files.\nHow to Get a Dump The game creates a dump file at C:\\ProgramData\\Mount and Blade II Bannerlord\\crashes after agreeing with the game prompt to send to the developers the crash report.\nAfter an UI with the file list will be shown, you don\u0026amp;rsquo;t need to interact with the interface.\nGo to C:\\ProgramData\\Mount and Blade II Bannerlord\\crashes. There will be a folder with a name similar to 2022-11-02_08.55.12. Open it and find a file called dump.dmp.\nThe dump file is fairly big, so we strongly recommend archiving it (zipping) before sending.\nFind a free file hosting like MediaFire and upload the archive. Post the link and we should be able to help!\nThanks!\n","date":1667419200,"description":"","lastmod":"2022-11-02T23:00:00+03:00","objectID":"270a867137b188ca7458149593268278","permalink":"https://butr.github.io/documentation/info/using-taleworld-crash-dump/","publishdate":"2022-11-02T23:00:00+03:00","title":"Using TaleWorld's Crash Dump"}]