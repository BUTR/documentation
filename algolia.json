[{"content":"","date":1508426775,"description":"Text about this post","lastmod":"2019-10-26T15:26:15Z","objectID":"3976528693a0108357f4928017600865","permalink":"https://butr.github.io/documentation/","publishdate":"2018-11-23T15:26:15Z","title":"Home title"},{"content":"","date":1639584240,"description":"","lastmod":"2021-12-15T19:04:00+03:00","objectID":"65a97066c0c3d6bcb7bfdd734849a02f","permalink":"https://butr.github.io/documentation/advanced/","publishdate":"2021-12-15T19:04:00+03:00","title":"Advanced"},{"content":"Introduction Sometimes you need to use a game function, but with some parts disabled. For example, Clan.OnCompanionAdded not only adds a hero to the clan companion list, but also adds him to the hero list.\npublic void OnCompanionAdded(Hero companion) { _companionsCache.Add(companion); OnHeroAdded(companion); // Function that adds the hero to the hero list } But what if we don\u0026amp;rsquo;t want this? One way you could just copy the function and get the maintenance burden of it.\nAnother way would be to use a Harmony reverse patch. You can get a copy of the function and manually manipulate the IL code to disable the OnHeroAdded call.\nWe suggest a higher level approach, based on using scopes and IDisposable.\nScoped Disabling Technique using allows us to create a scope. While this scope is active, we use a harmony patch that disables the execution of the unwanted function.\nusing (new AddCompanionActionHandler()) { // Within this scope any call to `OnHeroAdded` will be skipped. oldLeader.Clan.OnCompanionAdded(oldLeader); } The Harmony patch\npublic class AddCompanionActionHandler : IDisposable { public AddCompanionActionHandler() =\u0026amp;gt; AddCompanionActionPatch.SkipChange = true; public void Dispose() =\u0026amp;gt; AddCompanionActionPatch.SkipChange = false; } internal class AddCompanionActionPatch { internal static bool SkipChange = false; public static bool Enable(Harmony harmony) { return true \u0026amp;amp; harmony.TryPatch( original: AccessTools2.Method(typeof(Clan), \u0026amp;#34;OnHeroAdded\u0026amp;#34;), prefix: AccessTools2.Method(typeof(AddCompanionActionPatch), nameof(Prefix))); } private static bool Prefix() =\u0026amp;gt; !SkipChange; } ","date":1669329e3,"description":"","lastmod":"2022-11-25T01:30:00+03:00","objectID":"a38e875b00c573d97d1e931ce0277496","permalink":"https://butr.github.io/documentation/advanced/disabling-parts-of-external-functions/","publishdate":"2022-11-25T01:30:00+03:00","title":"Disabling Parts of External Functions"},{"content":"Introduction We created some easy to use reusable workflows that you can use to automatically publish your mods on NexusMods, Steam Workshop, NuGet/GPR and GitHub Releases.\nThe workflow is a multijob.\nFirst, you need to build your module on GitHub Actions and publish the binaries as an artifact.\nHere\u0026amp;rsquo;s an abstract example that uses Bannerlord.BuildResources for automatically building the mod with the proper structure.\nbuild-module: name: Build Module runs-on: ubuntu-latest steps: - name: Checkout Repository uses: actions/checkout@v2 - name: Setup .NET 6 uses: actions/setup-dotnet@master with: dotnet-version: 6.0.x - name: Build Bannerlord.Module run: \u0026amp;gt;- mkdir bannerlord; dotnet build src/Bannerlord.Module/Bannerlord.Module.csproj --configuration Release -p:GameFolder=\u0026amp;#34;$PWD/bannerlord\u0026amp;#34;; shell: pwsh - name: Upload Bannerlord folder uses: actions/upload-artifact@v3 with: name: bannerlord path: ./bannerlord/ NexusMods NexusMods will require you to set the proper ModId (nexusmods_mod_id), this is the number at the end of your mod url.\nAlso, it will require to set 2 secrets, NEXUSMODS_APIKEY and NEXUSMODS_COOKIES. You can get the ApiKey from here. The Cookies will require you to log in to NexusMods via Firefox. F12 and go to Network tab. Find any XHR method to nexusmods.com and copy the Cookies header. This is our NEXUSMODS_COOKIES secret.\n########################### # NEXUSMODS # ########################### publish-on-nexusmods: needs: [\u0026amp;#34;build-module\u0026amp;#34;] uses: BUTR/workflows/.github/workflows/release-nexusmods.yml@master with: nexusmods_game_id: mountandblade2bannerlord nexusmods_mod_id: 0 mod_filename: Bannerlord.Module mod_version: INJECT YOUR VERSION SOMEHOW mod_description: INJECT YOUR CHANGELOG SOMEHOW artifact_name: bannerlord secrets: NEXUSMODS_APIKEY: ${{ secrets.NEXUSMODS_APIKEY }} NEXUSMODS_COOKIES: ${{ secrets.NEXUSMODS_COOKIES }} Steam If Steam Guard is used, you need the STEAM_AUTH_CODE secret. Follow this url as a guide: You need to …","date":1669739400,"description":"","lastmod":"2022-11-29T19:30:00+03:00","objectID":"bbbddb8b17ba2493786a45cb5373f1ae","permalink":"https://butr.github.io/documentation/advanced/publishing-on-github/","publishdate":"2022-11-29T19:30:00+03:00","title":"Publishing Mods on GitHub Actions (NexusMods, Steam Workshop, NuGet)"},{"content":"Introduction Using any of the MemberInfo types is slow. Especially when they are not cached.\nA better way for accessing type members is to create delegates, with them the access speed is on pair with direct access.\nHarmony created a helper class AccessTools for those cases and BUTR created an extended version of it.\nIn this article we\u0026amp;rsquo;ll show how you can speed up your code.\nCaching Always cache the reflection if it\u0026amp;rsquo;s gonna be called multiple times.\nHarmony We strongly recommend to check first the Harmony Documentation as the code base is based on it.\nYou will also need Harmony.Extensions for the AccessTools2 class.\nAccessing fields // Usually it\u0026amp;#39;s done like this: private static readonly FieldInfo? Info = AccessTools2.Field(typeof(LauncherModuleVM), \u0026amp;#34;Info\u0026amp;#34;); // And then invoked like this: LauncherModuleVM obj = ...; // the LauncherModuleVM instance if (Info is not null) { string str = Info.GetValue(obj); Info.SetValue(obj, \u0026amp;#34;newstr\u0026amp;#34;); } // Instead use AccessTools.FieldRef private static readonly AccessTools.FieldRef\u0026amp;lt;string, LauncherModuleVMType\u0026amp;gt;? Info = AccessTools2.FieldRefAccess\u0026amp;lt;string, LauncherModuleVMType\u0026amp;gt;(\u0026amp;#34;Info\u0026amp;#34;); LauncherModuleVM obj = ...; // the LauncherModuleVM instance if (Info is not null) { string str = Info(obj); Info(obj) = \u0026amp;#34;newstr\u0026amp;#34;; } Calling methods // Usually it\u0026amp;#39;s done like this: private static readonly MethodInfo? Method = AccessTools2.Method(typeof(LauncherModuleVM), \u0026amp;#34;Method\u0026amp;#34;); // And then invoked like this: LauncherModuleVM obj = ...; // the LauncherModuleVM instance if (Method is not null) { bool b = Info.Invoke(obj, new object[] {}); } // Instead use AccessTools.FieldRef private delegate bool MethodDelegate(LauncherModuleVM instance); private static readonly MethodDelegate Method = AccessTools2.GetDelegate\u0026amp;lt;MethodDelegate\u0026amp;gt;(typeof(LauncherModuleVM), \u0026amp;#34;Method\u0026amp;#34;); LauncherModuleVM obj = ...; // the LauncherModuleVM instance if (Method is not null) { bool b = …","date":1639650721,"description":"","lastmod":"2021-12-16T13:32:01+03:00","objectID":"a8c30552768c06117b59c79bb1c7ba54","permalink":"https://butr.github.io/documentation/advanced/switching-from-membertinfo-to-accesstools2/","publishdate":"2021-12-16T13:32:01+03:00","title":"Switching from MemberInfo to AccessTools2"},{"content":"Introduction Our BUTR mods have a famous history of backwards compatibility.\nWe use several techniques to achieve this without causing huge performance drops by using Harmony\u0026amp;rsquo;s built in reflection tools and caching.\nOne of the techniques we use is type wrapping.\nIt\u0026amp;rsquo;s used for several cases:\nWhen types are moved between assemblies. Generally, to fix this you need to recompile your mod with the new locations, but it won\u0026amp;rsquo;t be backwards compatible this way. Instead, we stop working with the type directly and wrap it as an object, exposing an abstraction to work with. Incompatible signature changes. The method signature was replaced without keeping the old signature. Depending on the game version, you\u0026amp;rsquo;ll need to call different methods. Type Move Read-life example of type move.\nIn our BUTRLoader, we target e1.5.0 as the minimal supported version. Since the type was moved in e1.5.x, we either need to have 2 compiled assemblies and load one depending on the game version (see Implementation Loading), or create a type wrapper, what we did.\n// The game at some point moved type ModuleInfo // TaleWorlds.Library.ModuleInfo // to // TaleWorlds.ModuleManager.ModuleInfo // The type can\u0026amp;#39;t be directly referenced and used because it\u0026amp;#39;s location // is not consistent anymore/ // So we instead create a wrapper class that access the type indirectly internal sealed class ModuleInfoWrapper { private delegate string GetIdDelegate(object instance); private delegate string GetAliasDelegate(object instance); private delegate bool GetIsSelectedDelegate(object instance); private static readonly Type? OldModuleInfoType = AccessTools2.TypeByName(\u0026amp;#34;TaleWorlds.Library.ModuleInfo\u0026amp;#34;); private static readonly Type? NewModuleInfoType = AccessTools2.TypeByName(\u0026amp;#34;TaleWorlds.ModuleManager.ModuleInfo\u0026amp;#34;); public static readonly Type? ModuleInfoType = OldModuleInfoType ?? NewModuleInfoType; private static readonly GetIdDelegate? GetId = …","date":1639580221,"description":"","lastmod":"2021-12-15T17:57:01+03:00","objectID":"ff51d580fb08e43ef450d500921197aa","permalink":"https://butr.github.io/documentation/advanced/type-wrapping/","publishdate":"2021-12-15T17:57:01+03:00","title":"Type Wrapping"}]