<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Home title on BUTR Documentation</title><link>https://butr.github.io/documentation/</link><description>Recent content in Home title on BUTR Documentation</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 19 Oct 2017 15:26:15 +0000</lastBuildDate><atom:link href="https://butr.github.io/documentation/index.xml" rel="self" type="application/rss+xml"/><item><title>Publishing Mods on GitHub Actions (NexusMods, Steam Workshop, NuGet)</title><link>https://butr.github.io/documentation/advanced/publishing-on-github/</link><pubDate>Tue, 29 Nov 2022 19:30:00 +0300</pubDate><guid>https://butr.github.io/documentation/advanced/publishing-on-github/</guid><description>Introduction We created some easy to use reusable workflows that you can use to automatically publish your mods on NexusMods, Steam Workshop, NuGet/GPR and GitHub Releases.
The workflow is a multijob.
Here&amp;rsquo;s a full example.
First, you need to build your module on GitHub Actions and publish the binaries as an artifact.
Here&amp;rsquo;s an abstract example that uses Bannerlord.BuildResources for automatically building the mod with the proper structure.
build-module: name: Build Module runs-on: ubuntu-latest steps: - name: Checkout Repository uses: actions/checkout@v2 - name: Setup .</description></item><item><title>Disabling Parts of External Functions</title><link>https://butr.github.io/documentation/advanced/disabling-parts-of-external-functions/</link><pubDate>Fri, 25 Nov 2022 01:30:00 +0300</pubDate><guid>https://butr.github.io/documentation/advanced/disabling-parts-of-external-functions/</guid><description>Introduction Sometimes you need to use a game function, but with some parts disabled. For example, Clan.OnCompanionAdded not only adds a hero to the clan companion list, but also adds him to the hero list.
public void OnCompanionAdded(Hero companion) { _companionsCache.Add(companion); OnHeroAdded(companion); // Function that adds the hero to the hero list } But what if we don&amp;rsquo;t want this? One way you could just copy the function and get the maintenance burden of it.</description></item><item><title>Advanced Stacktrace Analytics of Crash Reports</title><link>https://butr.github.io/documentation/advanced/advanced-analytics-crash-reports/</link><pubDate>Fri, 21 Oct 2022 23:45:00 +0300</pubDate><guid>https://butr.github.io/documentation/advanced/advanced-analytics-crash-reports/</guid><description>Introduction ButterLibÂ v2.2.4 added a new entry in its Crash Report section called Enhanced Stacktrace.
It provides more info about the stacktrace of the exception -every frame (method call) provides more info:
If the method is changed by Harmony, it shows the original method and any prefix, postfix, transpiler or finalizer that is added, included with the Module that introduces the patch; An IL Offset is added; IL Offsets You should be able to know now the line that caused the exception, even if no debug symbols were present at the time of the crash.</description></item><item><title>Switching from MemberInfo to AccessTools2</title><link>https://butr.github.io/documentation/advanced/switching-from-membertinfo-to-accesstools2/</link><pubDate>Thu, 16 Dec 2021 13:32:01 +0300</pubDate><guid>https://butr.github.io/documentation/advanced/switching-from-membertinfo-to-accesstools2/</guid><description>Introduction Using any of the MemberInfo types is slow. Especially when they are not cached.
A better way for accessing type members is to create delegates, with them the access speed is on pair with direct access.
Harmony created a helper class AccessTools for those cases and BUTR created an extended version of it.
In this article we&amp;rsquo;ll show how you can speed up your code.
Caching Always cache the reflection if it&amp;rsquo;s gonna be called multiple times.</description></item><item><title>Type Wrapping</title><link>https://butr.github.io/documentation/advanced/type-wrapping/</link><pubDate>Wed, 15 Dec 2021 17:57:01 +0300</pubDate><guid>https://butr.github.io/documentation/advanced/type-wrapping/</guid><description>Introduction Our BUTR mods have a famous history of backwards compatibility.
We use several techniques to achieve this without causing huge performance drops by using Harmony&amp;rsquo;s built in reflection tools and caching.
One of the techniques we use is type wrapping.
It&amp;rsquo;s used for several cases:
When types are moved between assemblies. Generally, to fix this you need to recompile your mod with the new locations, but it won&amp;rsquo;t be backwards compatible this way.</description></item></channel></rss>